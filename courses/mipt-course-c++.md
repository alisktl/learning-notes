# С++ ФПМИ лекции - основной поток

1. [Основные типы и операции над ними.](#основные-типы-и-операции-над-ними)
2. [Объявления, определения и области видимости. Выражения и операторы.](#объявления-определения-и-области-видимости-выражения-и-операторы)
3. [Выражения и операторы. Управляющие конструкции. Ошибки компиляции.](#выражения-и-операторы-управляющие-конструкции-ошибки-компиляции)
4. [Runtime errors, undefined behaviour. Указатели и операции над ними.](#runtime-errors-undefined-behaviour-указатели-и-операции-над-ними)
5. [Виды памяти. Массивы. Перегрузка функций](#виды-памяти-массивы-перегрузка-функций)
6. [Указатели на функции. Ссылки. Константы](#указатели-на-функции-ссылки-константы)
7. [Приведения типов. Классы и структуры. Модификаторы доступа](#приведения-типов-классы-и-структуры-модификаторы-доступа)
8. [Конструкторы, деструкторы, оператор присваивания и "правило трех"](#конструкторы-деструкторы-оператор-присваивания-и-правило-трех)

---

# Раздел №3
# Основные типы и операции над ними

## О разных компиляторах

Есть разные компиляторы, `clang` и `gcc` - основные компиляторы.

### **C** и **C++** компилятроов
- `clang`:
  - `clang` - **clang** компилятор для *C*
  - `clang++` - **clang** компилятор для *C++*
- `gcc`:
  - `gcc` - **GNU** компилятор для *C*
  - `g++` - **GNU** компилятор для *C++*

### Версии компилятора и версии языка
Версии компилятора и версии языка – это разные понятия.

Например, чтобы скомпилировать код с помощью **GNU** компилятора версии 10 и *C++* версии 20:
```
g++-10 -std=c++20 main.cpp
```

## Основные типы и операции над ними

### Целочисленные типы

Следующие типы имеют примерную длину (зависит от операционной системы и CPU):

- `short` – ≈2 bytes
- `int` – ≈4 bytes
- `long long` – ≈8 bytes
- `unsigned int` – ≈4 bytes
- `unsigned long long` – ≈8 bytes

Следующие типы имеют точную длину:
- `int8_t` – 1 byte
- `int16_t` – 2 bytes
- `int32_t` – 4 bytes
- `int64_t` – 8 bytes
- `int128_t` – 16 bytes
- `uint8_t` – 1 byte
- `uint16_t` – 2 bytes
- `uint32_t` – 4 bytes
- `uint64_t` – 8 bytes
- `uint128_t` – 16 bytes

### char
Тип данных `char` предназначен для хранения одного символа и занимает 1 байт памяти. Каждому символу соответствует 8-битное целое значение – ASCII-код. Таким образом тип *char* может использоваться для хранения целых чисел от `-128` до `127` или от `0` до `255` (в зависимости от того, какой из типов используется: `signed char` и `unsigned char`).

### Типы с плавающей точкой

Следующие типы имеют примерную длину (зависит от операционной системы и CPU):

- `float` – ~4 bytes
- `double` – ~8 bytes
- `long double` – ~16 bytes

[Дополнительный код](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4) – способ представления чисел с плвавющей точкой в компьютерах.

### Тип `bool` и логические операции
Логические операции:
- `&&`
- `||`
- `!`
- `!=`
- `==`

Побитовые операции:
- `&`
- `|`

### `std::string`
Объект типа `string` содержит последовательность символов типа *char*, которая может быть пустой.

```
std::string s = "abc";
s[0] == 'a';
'a' + s == "aabc";
s.size();
```

### `std::vector<>`

`vector` – динамический массив.

```
std::vector<int> = {1, 2 3 4 5};
v[3] == 4;
v.push_back(6);
v.pop_back();
```

### `std::set<int>` и `std::multiset<int>`, `std::map<std::string, int>` и `std::multimap<std::string, int>`
set:
```
std::set<int> s;
s.size();
s.insert(3);
s.erase(3);
s.count(2);

for (int x: s) {
  std::cout << x << '\n';
}
```

map:
```
std::map<std::string, int> m;
m["abc"] = 1;
m["aaa"] = 2;
std::cout << m["aaa"];
```

---

# Объявления, определения и области видимости. Выражения и операторы.

## Объявления и определения переменных
```
int a; // declaration and definition, because it has some value
int b = 5; // declaration and definition
```

## Объявления и определения функций
```
int f(int x); // declaration;

// definition
int f(int x) {
  return x + 1;
}
```

## Связь определения и объявления
**Rule**: Any definition is a declaration;

## Разница между определением и объявлением функций
В одной области видимости можно объявлять функцию много раз, определять функцию можно только один раз.

## Области видимости
Область видимости представляет часть программы, в пределах которой можно использовать объект. Как правило, область видимости ограничивается блоком кода, который заключается в фигурные скобки. В зависимости от области видимости создаваемые объекты могут быть глобальными, локальными или автоматическими.

### Глобальные объекты
Глобальные переменные определены в файле программы вне любой из функций или любого другого блока кода и могут использоваться любой функцией. Глобальные переменные существуют в течение всей жизни программы и уничтожаются лишь с завершением программы.

```
int x = 5;

int main() {
  std::cout << x << '\n';
}
```

Глобальные переменные можно переопределить в другой области видимости. Так же можно получить глобальную переменную с помощью оператора `::`:
```
int x = 3;

int main() {
  int x = 5;
  {
    int x = 10;
    std::cout << x << '\n'; // 10
    std::cout << ::x << '\n'; // 3
  }
  std::cout << x << '\n'; // 5
  std::cout << ::x << '\n'; // 3
}
```

## Пространства имен
Пространство имен позволяет сгруппировать функционал в отдельные контейнеры. Пространство имен представляет блок кода, который содержит набор компонентов (функций, классов и т.д.) и имеет некоторое имя, которое прикрепляется к каждому компоненту из этого пространства имен. Полное имя каждого компонента – это имя пространства имен, за которым следует оператор `::` (оператор области видимости или scope operator) и имя компонента.

**Глобальное пространство имен** – если пространство имен не указано, то по умолчанию применяется глобальное пространство имен. применяется по умолчанию, если пространство имен не было определено. Все имена в глобальном пространстве имен такие же, как вы их объявляете, без прикрепления имени пространства имен:
```
int x = 3;

int main() {
  std::cout << x << '\n'; // 3
  std::cout << ::x << '\n'; // 3
}
```

**Определение пространства имен.** Для определения пространства имен применяется ключевое слово namespace, за которым идет название имени пространства имен:
```
namespace new_namespace {
  int x = 10;

  int f(int y) {
    return y + 1;
  }
}

namespace new_namespace_2 {
  int f(int y);
}

int new_namespace_2::f(int y) {
  return y + 2;
}

int main() {
  std::cout << new_namespace::x << '\n'; // 10

  new_namespace::x = 13;
  std::cout << new_namespace::x << '\n'; // 13

  std::cout << new_namespace::f(10) << '\n'; // 11
  std::cout << new_namespace_2::f(10) << '\n'; // 12
}
```

## Директива `using`
### Использование #1: using-объявления для новых названий типов
```
int main() {
  using vi = std::vector<int>;
  vi v = {1, 2, 3, 4, 5};

  for (int a: v) {
    std::cout << a << ' ';
  }
}
```

```
using vi = std::vector<int>;

int main() {
  vi v = {1, 2, 3, 4, 5};

  for (int a: v) {
    std::cout << a << ' ';
  }
}
```

### Использование #2: using-объявления для внесения в локальную область
```
namespace N {
  int x = 3;
}

int main() {
  using N::x;
  std::cout << x << '\n'; // 3
}
```

### Использование #3: `using namespace`, и почему это плохо
```
namespace N {
  int x = 3;
}

int main() {
  using namespace N;
  std::cout << x << '\n'; // 3
}
```

## Выражения и операторы (expressions and operators)
TODO: add

## Арифметические и побитовые операторы. Оператора сравнения
TODO: add

## Логические операторы
TODO: add

## Инкремент и декремент
TODO: add

## Присваивания и составные присваивания
TODO: add

---

# Выражения и операторы. Управляющие конструкции. Ошибки компиляции

## Понятия `lvalue` и `rvalue`
TODO: add

## Тернарный оператор
```
int main() {
  int a {5};
  int b {8};
  int c = a > b ? a - b : a + b;
 
  std::cout << "c = " << c << std::endl; // c = 13
}
```

```
x < 2 ? x = 1 : ++x;
```
```
x = (a == 1 ? 1 : 2);
```

## Оператор запятая
OK:
```
x = 1, y = 5, ++z;
```
```
(x = 5, ++x) = 1;
```

not OK:
```
(x = 5, x++) = 1;
```

## оператор `sizeof`
Получение вол-ва байт переменной в памяти:
```
int x = 1;
std::cout << sizeof x << '\n' // 4
```

## Приоритет операторов
[C++ Operator Precedence](https://en.cppreference.com/w/cpp/language/operator_precedence.html)

## Управляющие конструкции (Control statements)
### *if*
```
if (bool-expr) statement; {}
[else statement;]
```

### *while*
```
while (bool-expr) statement;
```

### *while-do*
```
do statement; while (bool-expr);
```

### *for*
```
for (init-statement; bool-expr; expr) statement;
```

### *switch*
```
switch (x) {
  case 1: statements; break;
  case 2: statements; break;
  default: statements; break;
}
```

## Errors
### Compilation Error
TODO: add

---

# Runtime errors, undefined behaviour. Указатели и операции над ними.

## Errors (продолжение)
### Runtime Error
#### Segmentation Fault
```
int main() {
  std::vector<int> v(10);
  v[1000000000] = 123;
  std::cout << v[1000000000] << std::endl;
}
```
Произошла ошибка `segmentation fault` произошла по причине того, что программа вышла за пределы выделенного сегмента памяти.

### Undefined Behaviour
Неопределенное поведение происходит при
- обращении за границу массива
- переполнение int
и т.д.

#### Пример
```
int main() {
  for (int i = 0; i < 300; ++i) {
    std::cout << i << ' ' << i*12345678 << std::endl;
  }
}
```

Скомпилировать с флагом `-02`, что дает оптимиззацию компиляции
```
g++ -02 main.cpp
```

В результате будет выводиться бесконечное кол-во строк. Поскольку оптимизация работает примерно так:
- Компилятор предполагает, что i*12345678 не превысит INT_MAX;
- INT_MAX / 12345678 = 173
- Поскольку 300 > 173, то компилятор не проверяет `i < 300`, поскольку `i < 300 == true` при том, что компилятор думает, что i все равно больше 173

### Unspecified Behaviour
TODO: add

## Почему C++ быстрее остальных языков
Поскольку в *C++* нет лишних проверок (проверка переполнения int, проверка выхода за пределы массива и т.д. [в других языках есть проверка и выкидание ошибки, в C++ не выкидывает ошибки])

---
# Раздел №2

## Указатели, операции взятия адреса и разыменования
### Указатель, и указатель на указатель
```
int main() {
  int a = 2;
  int* p = &a;
  std::cout << p << '\n';

  int** pp = &p;
  std::cout << pp << '\n';

  std::cout << (pp - p) << '\n';
}
```

### Получение значения по адресу
```
int main() {
  int a = 2;
  int* p = &a;
  std::cout << p << " -> " << *p << '\n';

  int** pp = &p;
  std::cout << pp << " -> " << *pp << '\n';
  std::cout << pp << " -> " << *pp << " -> " << **pp << '\n';
}
```

## Реализация функции `swap`
```
void swap(int* a, int* b) {
  int temp = *a;
  *a = *b;
  *b = temp;
}

int main() {
  int a = 1;
  int b = 2;
  swap(&a, &b);
  std::cout << a << ' ' << b << std::endl;
}
```

## Арифметические операции над указателями
Арифметические операции над указателями:
- `++`
- `--`
- `+n`
- `-n`
- `a - b`

Допустим:
```
int a = 2;
int* p = &a;
```
Пусть, `p = 0x16d1d7104`, тогда `p + 1` равен `0x16d1d7108`, т.е. к адресу прибавилось число 4, поскольку тип int занимает 4 байта.

---

# Виды памяти. Массивы. Перегрузка функций

## `NULL` vs `nullptr`
- `NULL` – это наследие *C*, в качестве нулевого указателя используется *0*
- `nullptr` – это предпочтительны ключевое слово, введенное в *C++11* для описания константы нулевого указателя.

## Виды памяти
Существуют несколько видов памяти для C++. Основные из них – `data`, `text`, `stack`.

### `data` или `static memory`
Память `data` (или `static memory`) используется для хранения статичных данных, таких как статичные переменные и т.д. При запуске, еще до вызова *main()*, статические данные загружаются в `data`, и хранятся там до завершения программы.

### `text`
В этой памяти хранятся инструкии скомпилированного кода.

### `stack` или `автоматическая память`
Стэковая память используется для хранения переменных, созданных в течении работы программы. В стэковой памяти есть указатель, который указывает на первую свободную ячейку памяти. Когда программа выходит из области видимости, то указатель передвигается на область, на которой он был до момента входа в область видимости. Стэковая память имеет фиксированный объем, обычно - *8МБ* или *16МБ*.

## Адрес возврата
При вызове функции в стек заносится адрес возврата – адрес в памяти (*text memory*) следующей инструкции приостановленной программы и управление передается функции. При последующем вложенном или рекурсивном вызове, прерывании функции в стек заносится очередной адрес возврата и т. д.

При возврате из функции, адрес возврата снимается со стека и управление передается на следующую инструкцию приостановленной (под-)программы.

## Переполнение стека (**stack overflow**)
Переполнение стека возникает, когда в стековой памяти хранится больше информации, чем он может вместить. Обычно ёмкость стека задаётся при старте программы/потока. Когда указатель стека выходит за границы, программа аварийно завершает работу.

Простейший пример бесконечной рекурсии на *C*:
```
int foo() {
     return foo();
}
```

## Динамическая память
**Динамическая память** – это память, которая выделяется в *RAM* оперативной системой в *runtime*. В динамической памяти хранятся объекты, которые были созданы с потомщью оператора `new`;

### Оператор `new`
Примеры объектов, созданных в динамической памяти:
```
T* p = new T(...) // T - это какой-то класс
int* a = new int(3)
vector<int> b = {1, 2, 3, 4}; // vector хранится в динамической памяти
```

### Оператор `delete` и проблема утечка памяти
После того, как необходимость в объекте отпадает, то надо удалить объект (сообщить операционной системе, что надо определенный участок памяти отвязать от программы) с помощью `delete`:
```
delete a;
```

Если не удалять объект, то это приведет к утечке памяти (*momery leak*).

### `vector<>`
В векторе уже встроено удаление объекта из динамической памяти.

## Массивы в стиле *C*

### Создание массива в стековой памяти
Создание массива в стековой памяти:
```
int a[3] = {1, 2, 3};
```

### Создание массива в динамической памяти
```
int* b = new int[1000];
*(b+1) = 5; // то же самое, что и b[1] = 5;

int* c = b + 5; // 'c' указывает на элемент под индексом 5
c[-3] = 1; // то же самое, что и b[2] = 1;

b[3] = 4; // то же самое, что и *(b + 3) = 4;
4[b] = 5; // то же самое, что и *(4 + b) = 5;
```

### Удаление массива в динамической памяти
```
delete[] b;
```

### Массивы переменной длины (*variable length arrays*)
Не желательно создавать массивы переменной длины в стековой памяти:
```
int n;
std::cin >> n;

int a[n];
```
Поскольку это не прописано в спецификации.

## Array-to-pointer conversion
Мы можем работать с массивом как с указателем, но не наоборот:
```
int a[100];
int* b = new int[100];

b = a; // OK
a = b; // NOT OK
```

Но:
```
sizeof a == 400; // true -> поскольку массив 'a' занимает 400 байт
sizeof b == 4; // true -> поскольку указатель указывает только на первую ячейку памяти

b = a;
sizeof b == 4; // true -> даже после конверсии, 'b' остается указателем на первую ячейку
```

## Перегрузка функций
Можно создать одинаковые функции, но с разными параметрами:
```
int f(double) {
  return 1;
}

int f(int) {
  return 2;
}

int main() {
  std::cout << f(1) << ' ' << f(1.0) << std::endl;  // 2 1
}
```

Правила перегрузки можно посмотреть [здесь](https://en.cppreference.com/w/cpp/language/overload_resolution.html)

# Указатели на функции. Ссылки. Константы

## Функции с переменным числом аргументов и с аргументами по умолчанию

### Функции с переменным числом аргументов (*Variadic functions*)
TODO: add

### Функции c аргументами по умолчанию
```
double f(int x, double d = 0.5) {
  return x * d;
}

int main() {
  std::cout << f(10) << '\n';  // 5
  std::cout << f(10, 0.7) << '\n';  // 7
}
```

Нельзя перегружать функции c аргументами по умолчанию с меньшим кол-вом аргументов:
```
// Compilation error
double f(int x) {
  return x * 0.5;
}
```

Можно перегружать функции c аргументами по умолчанию с одинаковым кол-вом аргументов:
```
// Compiles
double f(double x, double d = 2) {
  return x * d;
}
```

## Указатели на функции, пример применения для сортировки
```
double f(int x, double d) {
    return x * d;
}

int main() {
  double (*p)(int, double) = &f;

  std::cout << p << std::endl;  // always prints '1' for function pointer
  std::cout << p(3, 4) << std::endl;  // 12
}
```

### Применение указателя на функцию как аргумент
```
// Сортировка по близости к числу 5
bool compare(int x, int y) {
    return abs(x - 5) < abs(y - 5);
}

int main() {
  int nums[10] = {5, 3, 6, 7, 10, 2, 3, 6, 7, 3};
  std::sort(nums, nums + 10, &compare);
  //std::sort(nums, nums + 10, compare);

  for (auto num: nums) {
    std::cout << num << ' ';
  }

  std::cout << std::endl;
}
```

## *inline* функции (Встраиваемые функции)
Ключевое слово *inline* встраивает машинный код функции не отдельно, а в линии, где оно будет вызвано.

**NOTE**: Не желательно использовать *inline*.

## Ссылки
```
int a = 5;
int& b = a;

vector<int> v = {1, 2, 3};
vector<int>& v2 = v;
```

На данный момент, мы должны воспринимать так: ссылки - это то же самое, что и переменная. Если изменяется одно, то и другое изменяется (вернее, не изменяется, а просто ссылается на один адрес в памяти).

## Особенности инициализации ссылок
```
void f(int a) {
  a += 1;
}

void f(int& a) {
  a += 1;
}

int a = 1;

f(a);  // Compilation error
int& r;  // Compilation error
int& r = 5;  // Compilation error
int&* p = &a;  // Compilation error
```

## Перегрузка функций с аргументами с сылками и без
**Compilation Error:**
```
void f(int a) {
  ...
}

void f(int& a) {
  ...
}
```

## Реализация *swap* с использованием ссылок
```
void swap(int& a, int& b) {
  int t = a;
  a = b;
  b = t;
}

int main() {
  int a = 4;
  int b = 6;
  swap(a, b);
  std::cout << "a = " << a << '\n';
  std::cout << "b = " << b << std::endl;
}
```

## Как компилятор реализовывает ссылки
```
void f(int &r);

int main() {
    int x = 0;
    int *p = &x;
    int &r = x;
    int y = 1;
    double d = 3.14;

    std::cout << &d << ' ' << &y << ' ' << &p << ' ' << &x << ' ' << '\n';
    f(x);
}

void f(int &r) {
    int x = 0;
    int *p = &x;
    std::cout << &r << '\n';
    std::cout << &x << ' ' << &p << '\n';

    std::cout << &p - 1 << ' ' << *(&p - 1) << '\n';
    std::cout << &p - 2 << ' ' << *(&p - 2) << '\n';
    std::cout << &p - 3 << ' ' << *(&p - 3) << '\n';

    for (int i = 4; i <= 200; i++) {
        std::cout << &p - i << ' ' << *(&p - i) << '\n';
    }
}
```

## Возвращение ссылок из функций, проблема *dangling reference*
```
int& f(int& x) {
  ++x;
  return x;
}

int& f(int x) {
  ++x;
  return x;
}

int main() {
  int a = 3;
  f(a);  // OK

  g(a);  // Undefined Bahaviour
}
```

## Почему в C++ не получается решить проблему ссылок так же, как в языках со сборкой мусора
TODO: add

## Константы, как правильно понимать концепцию констант
```
const int a = 5;
const vector<int> v = {1, 2, 3};
```

Константные типы – это другой тип, в котором отсутствуют операции изменения.

**Note:** `int` и `const int` – разные типы!

## Константные указатели и указатели на константу
### Указатели на константу
```
const int a = 5;
const int* p = &a;

++p; // OK
++*p; // Compilation Error
```

### Константные указатели
```
int b = 10;
int* const pp = &b;
++pp; // Compilation Error
```

### Можно сделать каст константный указатель на константный указатель на константу
```
const int* const ppp = pp; // Implicit cast (неявное привидение)
```

### Можно сделать каст константный указатель на константу на указатель на константу
```
const int* qq = ppp; // Because it's a copy
```

### Нельзя сделать каст константный указатель на константу на константный указатель
```
int* const q = ppp; // Compilation Error
```

## Константные ссылки
```
int a = 5;
int& r = a;
const int& cr = a; // OK
int& const ccr = a; // Illegal expression

++a;
std::cout << cr; // 6
```

## Три вида передачи аргументов: по значению, по ссылке и по константной ссылке
### По значению
```
void f(int a) {
  ...
}
```

### По ссылке
```
void f(vector<int> &a) {
  ...
}
```

### По константной ссылке
```
void f(const vector<int> &a) {
  ...
}
```

**Note:** Если вы передаете примитивный тип, то надо передавать по значению, поскольку хранение адреса требует больше памяти чем сам примитивный объект

## Почему константные ссылки могут продлевать жизнь объектов, а неконстантные – не могут
### Продление жизни объектов
```
const std::string& ref = std::string("hello");
std::cout << ref << '\n'; // "hello"
```

Без такого правила ссылочная переменная ref стала бы висячей (dangling reference) сразу после создания, потому что временный объект по умолчанию уничтожается в конце выражения, а мы пытались бы читать из уже освобождённой памяти. Правило «продления» позволяет безопасно держать ссылку на временный объект до конца жизни ссылки.

### Продление жизни объектов при передаче аргумента функции
```
void f(const int& a) {
    std::cout << a << std::endl;
}

int main() {
    int a = 12;

    f(12);
}
```

### Почему?
TODO: Add


# Приведения типов. Классы и структуры. Модификаторы доступа

## Вкратце о способах приведения типов в *C*
```
int a = 5;
double d = (double) d;
```

## `static_cast`
*static_cast* работает, если есть известное компилятору преобразование. Самое лучшее приведение типа
```
int a = 5;
double d = static_cast<double>(a);
```

## `reinterpret_cast`
*reinterpret_cast* позволяет преобразовать любой тип в любой тип. Это самый «низкоуровневый» из встроенных операторов приведения типов. В отличие от других кастов, он буквально переинтерпретирует биты одного объекта как объект другого типа, не меняя их содержимого. 
```
int a = 5;
double d2 = *reinterpret_cast<double*>(&a); // скорей всего будет не 5
```
Здесь каст происходит тупо. Допустим, *int* занимает *32* бита, а *double* занимает *64* бита, то каст берет *32* бита от *int*, затем еще берет соседние *32* бита. Из-за этого после преобразования, d2 будет скорей всего не числом *5*.

## `const_cast`
`const_cast` служит исключительно для добавления или удаления квалификаторов *const*.

### Добавление *const*
```
int x = 5;
const int& z = const_cast<const int&>(x);
```

Допустим, что есть две перегруженные функции, одна с *const*, тогда вызовется функция с *const*:
```
void f(int& a) {
  ...
}

// вызовется эта функция
void f(const int& a) {
  ...
}

int main() {
  int x = 5;
  const int& z = const_cast<const int&>(x);

  f(z);
}
```

### Удаление *const*
```
const int a = 5;
int& b = const_cast<int&>(a);
++b; // Возможно изменится (зависит от компилятора), но это UB (Undefined Bahaviour)
```

### Когда удаление *const* можно делать
Удаление *const* можно делать, если изначально он был не *const*:
```
int a = 5;
const int& b = const_cast<const int&>(a);
int& c = const_cast<int&>(b);
++c;
```

## *C*-стайл каст
Самый «универсальный» и самый «опасный» оператор приведения типов.
```
int i = 42;
double d = (double)i;    // классический С-стиль: явно указываем тип-приёмник
```

Когда компилятор встречает запись (T)expr (или T(expr)), он по стандарту пытается подобрать первый из следующих вариантов (в таком же порядке), который компилируется:
1. `const_cast<T>(expr)`
2. `static_cast<T>(expr)`
3. `reinterpret_cast<T>(expr)`
4. `const_cast<T>(static_cast<U>(expr))` или `static_cast<T>(const_cast<U>(expr))`
5. `dynamic_cast<T>(expr)`

---

# Раздел №3: Введение в ООП
## Классы и структуры, поля и методы

### Создание структуры:
```
struct S {
  int x;
  char c;
  std::string str;

  int f(double d) {
    std::cout << "Ahaha!" << d << '\n';
    return x + d;
  }
};

int main() {
  S s;
  std::cout << s.x << '\n';
  std::cout << s.str.size() << '\n';

  std::cout << s.f(3.14) << '\n';
}
```

### Создание класса:
```
class S {
public:
  int x;
  char c;
  std::string str;

  int f(double d) {
    std::cout << "Ahaha!" << d << '\n';
    return x + d;
  }
};

int main() {
  S s;
  std::cout << s.x << '\n';
  std::cout << s.str.size() << '\n';

  std::cout << s.f(3.14) << '\n';
}
```

### Различия класса и структуры
`struct` и `class` – это почти одно и то же, только в *struct* по умолчанию все функции и поля публичные, а в *class* по умолчанию все функции и поля приватные.

## Инициализация полей в структуре
```
struct S {
  int a = 1;
  int b = 2;
};
```

## Внутренние и локальные классы (структуры)
```
struct S {
  struct SS {
    int a = 1;
    int b = 2;
  };
};

int main() {
  struct Strange {
    int a = 3;
    int b = 4;
  };

  Strange strange;
  std::cout << strange.a << '\n';
  std::cout << strange.b << '\n';

  S::SS ss;
  std::cout << ss.a << '\n';
  std::cout << ss.b << '\n';
}
```

## Оператор стрелочка
```
struct S {
  int a = 1;
  int b = 2;
};

int main() {
  S s;
  S* p = &s;

  std::cout << p->a << '\n';
  std::cout << p->b << '\n';
}
```

## Агрегатная инициализация структур
```
struct S {
  int a;
  int b;
};

int main() {
  S s{1, 2};

  std::cout << s.a << '\n';
  std::cout << s.b << '\n';
}
```

## Определение метода вне тела структуры
```
struct S;

struct S {
  int a = 0;
  int b = 1;

  int f(double d);
};

int S::f(double d) {
  std::cout << "Ahaha!" << d << '\n';
  return a + d;
}

int main() {
  S s;

  std::cout << s.f(3.14) << std::endl;
}
```

## Ключевое слово `this`
Ключевое слово `this` – это оператор на текущий объект:
```
struct S;

struct S {
  int a = 2;
  int b = 3;

  S get() {
    std::cout << "Get Called!\n";
    return *this;
  }
};

int main() {
  S s;

  std::cout << s.get().a << std::endl;
}
```

## Размещение структур в памяти, эффекты от перестановки полей
Поля в структуре размещаются в том порядке, в котором они записаны:

### 24 байт
```
struct S {
  int a;
  double d;
  int b;
};

int main() {
  std::cout << sizeof(S) << '\n';
}
```

### 16 байт
```
struct S {
  int a;
  int b;
  double d;
};

int main() {
  std::cout << sizeof(S) << '\n';
}
```

## Понятие инкапсуляции, модификаторы доступа `private` и `public`
Инкапсуляция – механизм языка *C++*, ограничивающий доступ к составляющим объект компонентам (методам и атрибутам), делает их защищенными или приватными, то есть доступными только внутри объекта.

### Модификаторы доступа
- `public` – открытая часть класса
- `private` – скрытая от внешнего кода часть класса

```
struct S {
private:
  int a;
public:
  int b;
};
```

## Принцип "сначала разрешение перегрузки, потом проверка доступа"
```
class S {
private:
  int a;
  void f(int) {
    std::cout << 1;
  }

public:
  double d;
  void f(double) {
    std::cout << 2;
  }
};

int main() {
  S s;

  s.f(0);
}
```

## Функции-друзья и классы-друзья (Дружественные функции и классы)

### Дружественные функции
Дружественные функции – это функции, которые не являются членами класса, однако имеют доступ к его закрытым членам – переменным и функциям, которые имеют спецификатор `private`.
```
class S {
private:
  friend void g(int);

  int a;
  void f(int) {
    std::cout << 1;
  }

public:
  double d;
  void f(double) {
    std::cout << 2;
  }
};

void g(int) {
  S s;
  s.f(0);
}

int main() {
  g(0);
}
```

**Note:** Чем меньше дружественных функций, тем лучше.

### Дружественные классы
TODO: Add

## Понятие конструкторов, примеры простейших конструкторов
```
class Complex {
private:
  double re;
  double im;

public:
  Complex(double r, double i) {
    re = r;
    im = i;

    std::cout << "Constructor called\n";
  }
};

int main() {
  Complex c(1, 2);
}
```

## Списки инициализации полей в конструкторах
```
class Complex {
private:
  double re = 0.0;
  double im = 0.0;

public:
  Complex(double r, double i): re(r), im(i) {}
  Complex(double r): re(r) {}
};

int main() {
  Complex c1(1.2, 2.3);
  Complex c2(3.5);
}
```

**Node:** списки инициализации полей в конструкторах предпочтительней чем предыдущий вариант. Используя списки инициализации полей поля сразу инизиализируются аргументами, и не будут изначально инициализироваться дефолтными значениями. Эта разница сильнее заметна если использовать не примитивные типы в полях, а например *string* или *vector*.

# Конструкторы, деструкторы, оператор присваивания и "правило трех"





















