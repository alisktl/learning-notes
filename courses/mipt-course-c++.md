# С++ ФПМИ лекции - основной поток

1. [Основные типы и операции над ними.](#основные-типы-и-операции-над-ними)
2. [Объявления, определения и области видимости. Выражения и операторы.](#объявления-определения-и-области-видимости-выражения-и-операторы)
3. [Выражения и операторы. Управляющие конструкции. Ошибки компиляции.](#выражения-и-операторы-управляющие-конструкции-ошибки-компиляции)
4. [Runtime errors, undefined behaviour. Указатели и операции над ними.](#runtime-errors-undefined-behaviour-указатели-и-операции-над-ними)
5. [Виды памяти. Массивы. Перегрузка функций](#виды-памяти-массивы-перегрузка-функций)

---

# Основные типы и операции над ними

## О разных компиляторах

Есть разные компиляторы, `clang` и `gcc` - основные компиляторы.

### **C** и **C++** компилятроов
- `clang`:
  - `clang` - **clang** компилятор для *C*
  - `clang++` - **clang** компилятор для *C++*
- `gcc`:
  - `gcc` - **GNU** компилятор для *C*
  - `g++` - **GNU** компилятор для *C++*

### Версии компилятора и версии языка
Версии компилятора и версии языка – это разные понятия.

Например, чтобы скомпилировать код с помощью **GNU** компилятора версии 10 и *C++* версии 20:
```
g++-10 -std=c++20 main.cpp
```

## Основные типы и операции над ними

### Целочисленные типы

Следующие типы имеют примерную длину (зависит от операционной системы и CPU):

- `short` – ≈2 bytes
- `int` – ≈4 bytes
- `long long` – ≈8 bytes
- `unsigned int` – ≈4 bytes
- `unsigned long long` – ≈8 bytes

Следующие типы имеют точную длину:
- `int8_t` – 1 byte
- `int16_t` – 2 bytes
- `int32_t` – 4 bytes
- `int64_t` – 8 bytes
- `int128_t` – 16 bytes
- `uint8_t` – 1 byte
- `uint16_t` – 2 bytes
- `uint32_t` – 4 bytes
- `uint64_t` – 8 bytes
- `uint128_t` – 16 bytes

### char
Тип данных `char` предназначен для хранения одного символа и занимает 1 байт памяти. Каждому символу соответствует 8-битное целое значение – ASCII-код. Таким образом тип *char* может использоваться для хранения целых чисел от `-128` до `127` или от `0` до `255` (в зависимости от того, какой из типов используется: `signed char` и `unsigned char`).

### Типы с плавающей точкой

Следующие типы имеют примерную длину (зависит от операционной системы и CPU):

- `float` – ~4 bytes
- `double` – ~8 bytes
- `long double` – ~16 bytes

[Дополнительный код](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4) – способ представления чисел с плвавющей точкой в компьютерах.

### Тип `bool` и логические операции
Логические операции:
- `&&`
- `||`
- `!`
- `!=`
- `==`

Побитовые операции:
- `&`
- `|`

### `std::string`
Объект типа `string` содержит последовательность символов типа *char*, которая может быть пустой.

```
std::string s = "abc";
s[0] == 'a';
'a' + s == "aabc";
s.size();
```

### `std::vector<>`

`vector` – динамический массив.

```
std::vector<int> = {1, 2 3 4 5};
v[3] == 4;
v.push_back(6);
v.pop_back();
```

### `std::set<int>` и `std::multiset<int>`, `std::map<std::string, int>` и `std::multimap<std::string, int>`
set:
```
std::set<int> s;
s.size();
s.insert(3);
s.erase(3);
s.count(2);

for (int x: s) {
  std::cout << x << '\n';
}
```

map:
```
std::map<std::string, int> m;
m["abc"] = 1;
m["aaa"] = 2;
std::cout << m["aaa"];
```

---

# Объявления, определения и области видимости. Выражения и операторы.

## Объявления и определения переменных
```
int a; // declaration and definition, because it has some value
int b = 5; // declaration and definition
```

## Объявления и определения функций
```
int f(int x); // declaration;

// definition
int f(int x) {
  return x + 1;
}
```

## Связь определения и объявления
**Rule**: Any definition is a declaration;

## Разница между определением и объявлением функций
В одной области видимости можно объявлять функцию много раз, определять функцию можно только один раз.

## Области видимости
Область видимости представляет часть программы, в пределах которой можно использовать объект. Как правило, область видимости ограничивается блоком кода, который заключается в фигурные скобки. В зависимости от области видимости создаваемые объекты могут быть глобальными, локальными или автоматическими.

### Глобальные объекты
Глобальные переменные определены в файле программы вне любой из функций или любого другого блока кода и могут использоваться любой функцией. Глобальные переменные существуют в течение всей жизни программы и уничтожаются лишь с завершением программы.

```
int x = 5;

int main() {
  std::cout << x << '\n';
}
```

Глобальные переменные можно переопределить в другой области видимости. Так же можно получить глобальную переменную с помощью оператора `::`:
```
int x = 3;

int main() {
  int x = 5;
  {
    int x = 10;
    std::cout << x << '\n'; // 10
    std::cout << ::x << '\n'; // 3
  }
  std::cout << x << '\n'; // 5
  std::cout << ::x << '\n'; // 3
}
```

## Пространства имен
Пространство имен позволяет сгруппировать функционал в отдельные контейнеры. Пространство имен представляет блок кода, который содержит набор компонентов (функций, классов и т.д.) и имеет некоторое имя, которое прикрепляется к каждому компоненту из этого пространства имен. Полное имя каждого компонента – это имя пространства имен, за которым следует оператор `::` (оператор области видимости или scope operator) и имя компонента.

**Глобальное пространство имен** – если пространство имен не указано, то по умолчанию применяется глобальное пространство имен. применяется по умолчанию, если пространство имен не было определено. Все имена в глобальном пространстве имен такие же, как вы их объявляете, без прикрепления имени пространства имен:
```
int x = 3;

int main() {
  std::cout << x << '\n'; // 3
  std::cout << ::x << '\n'; // 3
}
```

**Определение пространства имен.** Для определения пространства имен применяется ключевое слово namespace, за которым идет название имени пространства имен:
```
namespace new_namespace {
  int x = 10;

  int f(int y) {
    return y + 1;
  }
}

namespace new_namespace_2 {
  int f(int y);
}

int new_namespace_2::f(int y) {
  return y + 2;
}

int main() {
  std::cout << new_namespace::x << '\n'; // 10

  new_namespace::x = 13;
  std::cout << new_namespace::x << '\n'; // 13

  std::cout << new_namespace::f(10) << '\n'; // 11
  std::cout << new_namespace_2::f(10) << '\n'; // 12
}
```

## Директива `using`
### Использование #1: using-объявления для новых названий типов
```
int main() {
  using vi = std::vector<int>;
  vi v = {1, 2, 3, 4, 5};

  for (int a: v) {
    std::cout << a << ' ';
  }
}
```

```
using vi = std::vector<int>;

int main() {
  vi v = {1, 2, 3, 4, 5};

  for (int a: v) {
    std::cout << a << ' ';
  }
}
```

### Использование #2: using-объявления для внесения в локальную область
```
namespace N {
  int x = 3;
}

int main() {
  using N::x;
  std::cout << x << '\n'; // 3
}
```

### Использование #3: `using namespace`, и почему это плохо
```
namespace N {
  int x = 3;
}

int main() {
  using namespace N;
  std::cout << x << '\n'; // 3
}
```

## Выражения и операторы (expressions and operators)
TODO: add

## Арифметические и побитовые операторы. Оператора сравнения
TODO: add

## Логические операторы
TODO: add

## Инкремент и декремент
TODO: add

## Присваивания и составные присваивания
TODO: add

---

# Выражения и операторы. Управляющие конструкции. Ошибки компиляции

## Понятия `lvalue` и `rvalue`
TODO: add

## Тернарный оператор
```
int main() {
  int a {5};
  int b {8};
  int c = a > b ? a - b : a + b;
 
  std::cout << "c = " << c << std::endl; // c = 13
}
```

```
x < 2 ? x = 1 : ++x;
```
```
x = (a == 1 ? 1 : 2);
```

## Оператор запятая
OK:
```
x = 1, y = 5, ++z;
```
```
(x = 5, ++x) = 1;
```

not OK:
```
(x = 5, x++) = 1;
```

## оператор `sizeof`
Получение вол-ва байт переменной в памяти:
```
int x = 1;
std::cout << sizeof x << '\n' // 4
```

## Приоритет операторов
[C++ Operator Precedence](https://en.cppreference.com/w/cpp/language/operator_precedence.html)

## Управляющие конструкции (Control statements)
### *if*
```
if (bool-expr) statement; {}
[else statement;]
```

### *while*
```
while (bool-expr) statement;
```

### *while-do*
```
do statement; while (bool-expr);
```

### *for*
```
for (init-statement; bool-expr; expr) statement;
```

### *switch*
```
switch (x) {
  case 1: statements; break;
  case 2: statements; break;
  default: statements; break;
}
```

## Errors
### Compilation Error
TODO: add

---

# Runtime errors, undefined behaviour. Указатели и операции над ними.

## Errors (продолжение)
### Runtime Error
#### Segmentation Fault
```
int main() {
  std::vector<int> v(10);
  v[1000000000] = 123;
  std::cout << v[1000000000] << std::endl;
}
```
Произошла ошибка `segmentation fault` произошла по причине того, что программа вышла за пределы выделенного сегмента памяти.

### Undefined Behaviour
Неопределенное поведение происходит при
- обращении за границу массива
- переполнение int
и т.д.

#### Пример
```
int main() {
  for (int i = 0; i < 300; ++i) {
    std::cout << i << ' ' << i*12345678 << std::endl;
  }
}
```

Скомпилировать с флагом `-02`, что дает оптимиззацию компиляции
```
g++ -02 main.cpp
```

В результате будет выводиться бесконечное кол-во строк. Поскольку оптимизация работает примерно так:
- Компилятор предполагает, что i*12345678 не превысит INT_MAX;
- INT_MAX / 12345678 = 173
- Поскольку 300 > 173, то компилятор не проверяет `i < 300`, поскольку `i < 300 == true` при том, что компилятор думает, что i все равно больше 173

### Unspecified Behaviour
TODO: add

## Почему C++ быстрее остальных языков
Поскольку в *C++* нет лишних проверок (проверка переполнения int, проверка выхода за пределы массива и т.д. [в других языках есть проверка и выкидание ошибки, в C++ не выкидывает ошибки])

## Указатели, операции взятия адреса и разыменования
### Указатель, и указатель на указатель
```
int main() {
  int a = 2;
  int* p = &a;
  std::cout << p << '\n';

  int** pp = &p;
  std::cout << pp << '\n';

  std::cout << (pp - p) << '\n';
}
```

### Получение значения по адресу
```
int main() {
  int a = 2;
  int* p = &a;
  std::cout << p << " -> " << *p << '\n';

  int** pp = &p;
  std::cout << pp << " -> " << *pp << '\n';
  std::cout << pp << " -> " << *pp << " -> " << **pp << '\n';
}
```

## Реализация функции `swap`
```
void swap(int* a, int* b) {
  int temp = *a;
  *a = *b;
  *b = temp;
}

int main() {
  int a = 1;
  int b = 2;
  swap(&a, &b);
  std::cout << a << ' ' << b << std::endl;
}
```

## Арифметические операции над указателями
Арифметические операции над указателями:
- `++`
- `--`
- `+n`
- `-n`
- `a - b`

Допустим:
```
int a = 2;
int* p = &a;
```
Пусть, `p = 0x16d1d7104`, тогда `p + 1` равен `0x16d1d7108`, т.е. к адресу прибавилось число 4, поскольку тип int занимает 4 байта.

---

# Виды памяти. Массивы. Перегрузка функций

## `NULL` vs `nullptr`
- `NULL` – это наследие *C*, в качестве нулевого указателя используется *0*
- `nullptr` – это предпочтительны ключевое слово, введенное в *C++11* для описания константы нулевого указателя.

## Виды памяти
Существуют несколько видов памяти для C++. Основные из них – `data`, `text`, `stack`.

### `data` или `static memory`
Память `data` (или `static memory`) используется для хранения статичных данных, таких как статичные переменные и т.д. При запуске, еще до вызова *main()*, статические данные загружаются в `data`, и хранятся там до завершения программы.

### `text`
В этой памяти хранятся инструкии скомпилированного кода.

### `stack` или `автоматическая память`
Стэковая память используется для хранения переменных, созданных в течении работы программы. В стэковой памяти есть указатель, который указывает на первую свободную ячейку памяти. Когда программа выходит из области видимости, то указатель передвигается на область, на которой он был до момента входа в область видимости. Стэковая память имеет фиксированный объем, обычно - *8МБ* или *16МБ*.

## Адрес возврата
При вызове функции в стек заносится адрес возврата – адрес в памяти (*text memory*) следующей инструкции приостановленной программы и управление передается функции. При последующем вложенном или рекурсивном вызове, прерывании функции в стек заносится очередной адрес возврата и т. д.

При возврате из функции, адрес возврата снимается со стека и управление передается на следующую инструкцию приостановленной (под-)программы.

## Переполнение стека (**stack overflow**)
Переполнение стека возникает, когда в стековой памяти хранится больше информации, чем он может вместить. Обычно ёмкость стека задаётся при старте программы/потока. Когда указатель стека выходит за границы, программа аварийно завершает работу.

Простейший пример бесконечной рекурсии на *C*:
```
int foo() {
     return foo();
}
```

## Динамическая память
**Динамическая память** – это память, которая выделяется в *RAM* оперативной системой в *runtime*. В динамической памяти хранятся объекты, которые были созданы с потомщью оператора `new`;

### Оператор `new`
Примеры объектов, созданных в динамической памяти:
```
T* p = new T(...) // T - это какой-то класс
int* a = new int(3)
vector<int> b = {1, 2, 3, 4}; // vector хранится в динамической памяти
```

### Оператор `delete` и проблема утечка памяти
После того, как необходимость в объекте отпадает, то надо удалить объект (сообщить операционной системе, что надо определенный участок памяти отвязать от программы) с помощью `delete`:
```
delete a;
```

Если не удалять объект, то это приведет к утечке памяти (*momery leak*).

### `vector<>`
В векторе уже встроено удаление объекта из динамической памяти.

## Массивы в стиле *C*

### Создание массива в стековой памяти
Создание массива в стековой памяти:
```
int a[3] = {1, 2, 3};
```

### Создание массива в динамической памяти
```
int* b = new int[1000];
*(b+1) = 5; // то же самое, что и b[1] = 5;

int* c = b + 5; // 'c' указывает на элемент под индексом 5
c[-3] = 1; // то же самое, что и b[2] = 1;

b[3] = 4; // то же самое, что и *(b + 3) = 4;
4[b] = 5; // то же самое, что и *(4 + b) = 5;
```

### Удаление массива в динамической памяти
```
delete[] b;
```

### Массивы переменной длины (*variable length arrays*)
Не желательно создавать массивы переменной длины в стековой памяти:
```
int n;
std::cin >> n;

int a[n];
```
Поскольку это не прописано в спецификации.

## Array-to-pointer conversion
Мы можем работать с массивом как с указателем, но не наоборот:
```
int a[100];
int* b = new int[100];

b = a; // OK
a = b; // NOT OK
```

Но:
```
sizeof a == 400; // true -> поскольку массив 'a' занимает 400 байт
sizeof b == 4; // true -> поскольку указатель указывает только на первую ячейку памяти

b = a;
sizeof b == 4; // true -> даже после конверсии, 'b' остается указателем на первую ячейку
```













































