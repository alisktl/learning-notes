# С++ ФПМИ лекции - основной поток

1. [Основные типы и операции над ними.](#основные-типы-и-операции-над-ними)
2. [Объявления, определения и области видимости. Выражения и операторы.](#объявления-определения-и-области-видимости-выражения-и-операторы)
3. [Выражения и операторы. Управляющие конструкции. Ошибки компиляции](#выражения-и-операторы-управляющие-конструкции-ошибки-компиляции)

---

# Основные типы и операции над ними

## О разных компиляторах

Есть разные компиляторы, `clang` и `gcc` - основные компиляторы.

### **C** и **C++** компилятроов
- `clang`:
  - `clang` - **clang** компилятор для *C*
  - `clang++` - **clang** компилятор для *C++*
- `gcc`:
  - `gcc` - **GNU** компилятор для *C*
  - `g++` - **GNU** компилятор для *C++*

### Версии компилятора и версии языка
Версии компилятора и версии языка – это разные понятия.

Например, чтобы скомпилировать код с помощью **GNU** компилятора версии 10 и *C++* версии 20:
```
g++-10 -std=c++20 main.cpp
```

## Основные типы и операции над ними

### Целочисленные типы

Следующие типы имеют примерную длину (зависит от операционной системы и CPU):

- `short` – ~2 bytes
- `int` – ~4 bytes
- `long long` – ~8 bytes
- `unsigned int` – ~4 bytes
- `unsigned long long` – ~8 bytes

Следующие типы имеют точную длину:
- `int8_t` – 1 byte
- `int16_t` – 2 bytes
- `int32_t` – 4 bytes
- `int64_t` – 8 bytes
- `int128_t` – 16 bytes
- `uint8_t` – 1 byte
- `uint16_t` – 2 bytes
- `uint32_t` – 4 bytes
- `uint64_t` – 8 bytes
- `uint128_t` – 16 bytes

### char
Тип данных `char` предназначен для хранения одного символа и занимает 1 байт памяти. Каждому символу соответствует 8-битное целое значение – ASCII-код. Таким образом тип *char* может использоваться для хранения целых чисел от `-128` до `127` или от `0` до `255` (в зависимости от того, какой из типов используется: `signed char` и `unsigned char`).

### Типы с плавающей точкой

Следующие типы имеют примерную длину (зависит от операционной системы и CPU):

- `float` – ~4 bytes
- `double` – ~8 bytes
- `long double` – ~16 bytes

[Дополнительный код](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4) – способ представления чисел с плвавющей точкой в компьютерах.

### Тип `bool` и логические операции
Логические операции:
- `&&`
- `||`
- `!`
- `!=`
- `==`

Побитовые операции:
- `&`
- `|`

### `std::string`
Объект типа `string` содержит последовательность символов типа *char*, которая может быть пустой.

```
std::string s = "abc";
s[0] == 'a';
'a' + s == "aabc";
s.size();
```

### `std::vector<>`

`vector` – динамический массив.

```
std::vector<int> = {1, 2 3 4 5};
v[3] == 4;
v.push_back(6);
v.pop_back();
```

### `std::set<int>` и `std::multiset<int>`, `std::map<std::string, int>` и `std::multimap<std::string, int>`
set:
```
std::set<int> s;
s.size();
s.insert(3);
s.erase(3);
s.count(2);

for (int x: s) {
  std::cout << x << '\n';
}
```

map:
```
std::map<std::string, int> m;
m["abc"] = 1;
m["aaa"] = 2;
std::cout << m["aaa"];
```

---

# Объявления, определения и области видимости. Выражения и операторы.

## Объявления и определения переменных
```
int a; // declaration and definition, because it has some value
int b = 5; // declaration and definition
```

## Объявления и определения функций
```
int f(int x); // declaration;

// definition
int f(int x) {
  return x + 1;
}
```

## Связь определения и объявления
**Rule**: Any definition is a declaration;

## Разница между определением и объявлением функций
В одной области видимости можно объявлять функцию много раз, определять функцию можно только один раз.

## Области видимости
Область видимости представляет часть программы, в пределах которой можно использовать объект. Как правило, область видимости ограничивается блоком кода, который заключается в фигурные скобки. В зависимости от области видимости создаваемые объекты могут быть глобальными, локальными или автоматическими.

### Глобальные объекты
Глобальные переменные определены в файле программы вне любой из функций или любого другого блока кода и могут использоваться любой функцией. Глобальные переменные существуют в течение всей жизни программы и уничтожаются лишь с завершением программы.

```
int x = 5;

int main() {
  std::cout << x << '\n';
}
```

Глобальные переменные можно переопределить в другой области видимости. Так же можно получить глобальную переменную с помощью оператора `::`:
```
int x = 3;

int main() {
  int x = 5;
  {
    int x = 10;
    std::cout << x << '\n'; // 10
    std::cout << ::x << '\n'; // 3
  }
  std::cout << x << '\n'; // 5
  std::cout << ::x << '\n'; // 3
}
```

## Пространства имен
Пространство имен позволяет сгруппировать функционал в отдельные контейнеры. Пространство имен представляет блок кода, который содержит набор компонентов (функций, классов и т.д.) и имеет некоторое имя, которое прикрепляется к каждому компоненту из этого пространства имен. Полное имя каждого компонента – это имя пространства имен, за которым следует оператор `::` (оператор области видимости или scope operator) и имя компонента.

**Глобальное пространство имен** – если пространство имен не указано, то по умолчанию применяется глобальное пространство имен. применяется по умолчанию, если пространство имен не было определено. Все имена в глобальном пространстве имен такие же, как вы их объявляете, без прикрепления имени пространства имен:
```
int x = 3;

int main() {
  std::cout << x << '\n'; // 3
  std::cout << ::x << '\n'; // 3
}
```

**Определение пространства имен.** Для определения пространства имен применяется ключевое слово namespace, за которым идет название имени пространства имен:
```
namespace new_namespace {
  int x = 10;

  int f(int y) {
    return y + 1;
  }
}

namespace new_namespace_2 {
  int f(int y);
}

int new_namespace_2::f(int y) {
  return y + 2;
}

int main() {
  std::cout << new_namespace::x << '\n'; // 10

  new_namespace::x = 13;
  std::cout << new_namespace::x << '\n'; // 13

  std::cout << new_namespace::f(10) << '\n'; // 11
  std::cout << new_namespace_2::f(10) << '\n'; // 12
}
```

## Директива `using`
### Использование #1: using-объявления для новых названий типов
```
int main() {
  using vi = std::vector<int>;
  vi v = {1, 2, 3, 4, 5};

  for (int a: v) {
    std::cout << a << ' ';
  }
}
```

```
using vi = std::vector<int>;

int main() {
  vi v = {1, 2, 3, 4, 5};

  for (int a: v) {
    std::cout << a << ' ';
  }
}
```

### Использование #2: using-объявления для внесения в локальную область
```
namespace N {
  int x = 3;
}

int main() {
  using N::x;
  std::cout << x << '\n'; // 3
}
```

### Использование #3: `using namespace`, и почему это плохо
```
namespace N {
  int x = 3;
}

int main() {
  using namespace N;
  std::cout << x << '\n'; // 3
}
```

## Выражения и операторы (expressions and operators)
TODO: add

## Арифметические и побитовые операторы. Оператора сравнения
TODO: add

## Логические операторы
TODO: add

## Инкремент и декремент
TODO: add

## Присваивания и составные присваивания
TODO: add

---

# Выражения и операторы. Управляющие конструкции. Ошибки компиляции

## Понятия `lvalue` и `rvalue`
TODO: add

## Тернарный оператор
```
int main() {
  int a {5};
  int b {8};
  int c = a > b ? a - b : a + b;
 
  std::cout << "c = " << c << std::endl; // c = 13
}
```

```
x < 2 ? x = 1 : ++x;
```
```
x = (a == 1 ? 1 : 2);
```

## Оператор запятая
OK:
```
x = 1, y = 5, ++z;
```
```
(x = 5, ++x) = 1;
```

not OK:
```
(x = 5, x++) = 1;
```

## оператор `sizeof`
Получение вол-ва байт переменной в памяти:
```
int x = 1;
std::cout << sizeof x << '\n' // 4
```

## Приоритет операторов
[C++ Operator Precedence](https://en.cppreference.com/w/cpp/language/operator_precedence.html)

## Управляющие конструкции (Control statements)
### *if*
```
if (bool-expr) statement; {}
[else statement;]
```

### *while*
```
while (bool-expr) statement;
```

### *while-do*
```
do statement; while (bool-expr);
```

### *for*
```
for (init-statement; bool-expr; expr) statement;
```

### *switch*
```
switch (x) {
  case 1: statements; break;
  case 2: statements; break;
  default: statements; break;
}
```

## Errors
### Compilation Error
TODO: add

---

# Runtime errors, undefined behaviour. Указатели и операции над ними.

## Errors (продолжение)
### Runtime Error
#### Segmentation Fault
```
int main() {
  std::vector<int> v(10);
  v[1000000000] = 123;
  std::cout << v[1000000000] << std::endl;
}
```
Произошла ошибка `segmentation fault` произошла по причине того, что программа вышла за пределы выделенного сегмента памяти.

### Undefined Behaviour
Неопределенное поведение происходит при
- обращении за границу массива
- переполнение int
и т.д.

#### Пример
```
int main() {
  for (int i = 0; i < 300; ++i) {
    std::cout << i << ' ' << i*12345678 << std::endl;
  }
}
```

Скомпилировать с флагом `-02`, что дает оптимиззацию компиляции
```
g++ -02 main.cpp
```

В результате будет выводиться бесконечное кол-во строк. Поскольку оптимизация работает примерно так:
- Компилятор предполагает, что i*12345678 не превысит INT_MAX;
- INT_MAX / 12345678 = 173
- Поскольку 300 > 173, то компилятор не проверяет `i < 300`, поскольку `i < 300 == true` при том, что компилятор думает, что i все равно больше 173

### Unspecified Behaviour
TODO: add

## Почему C++ быстрее остальных языков
Поскольку в *C++* нет лишних проверок (проверка переполнения int, проверка выхода за пределы массива и т.д. [в других языках есть проверка и выкидание ошибки, в C++ не выкидывает ошибки])































