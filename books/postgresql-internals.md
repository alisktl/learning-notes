# PostgreSQL 16 изнутри
by Рогов Егор Валерьевич

- Часть 0.
  - Глава 1. Введение
    1. Организация данных
    2. Процессы и память
    3. Клиенты и клиент - серверный протокол
- Часть I. Изоляция и многоверсионность
  - Глава 2. Изоляция
    1. Согласованность
    2. Уровни изоляции и аномалии в стандарте SQL
    3. Уровни изоляции в PostgreSQL
   
---

## Глава 1. Введение

### Организация данных

#### Базы данных
- `PostgreSQL` - программа, которая относится к классу систем управления [базами данных](https://postgrespro.ru/docs/postgresql/16/managing-databases). Когда эта программа выполняется, мы называем ее `сервером` PostgreSQL, или `экземпляром` сервера.
- Данные, которыми управляет PostgreSQL, хранятся в `базах данных`.
- Один экземпляр PostgreSQL одновременно работает с несколькими базами, которые вместе называются `кластером баз данных`.
- Чтобы кластер можно было использовть, его необходимо `инициализировать` [[`initdb`](https://postgrespro.ru/docs/postgresql/16/app-initdb)]. Каталог, в котором размещаются все файлы, относящиеся к кластеру, обычно называют словом `PGDATA`. Обычно `PGDATA` находится в `/var/lib/pgsql/data`.
- При инициализации в PGDATA создаются три одинаковые базы данных:
  - `template0` - неизменяемый эталон
  - `template1` - настраиваемый шаблон для новых баз.
  - `postgres` - удобная «рабочая» БД для администрирования и тестов.
 
#### Системный каталог
- Метаинформация обо всех объектах кластера (таких как таблицы, индексы, типы данных или функции) хранится в таблицах, относящихся к [`системному каталогу`](https://postgrespro.ru/docs/postgresql/16/catalogs).
- К системному каталогу можно обращаться с помощью обычных запросов SQL, а изменения в нем происходят при выполнении команд DDL.

#### Схемы
- [`Схемы`](https://postgrespro.ru/docs/postgresql/16/ddl-schemas) представляют собой пространства имен для всех объектов, хранящихся в базе данных.
- Кроме пользовательских схем, имеется несколько специальных служебных:
  - `public` используется по умолчанию для пользовательских объектов, если не выполнены иные настройки
  - `pg_catalog` используется для таблиц системного каталога
  - `information_schema` дает альтернативное представление системного каталога, регламентируемое стандартом SQL
  - `pg_toast` используется для объектов, относящихся к TOAST
  - `pg_temp` объединяет временные таблицы

 #### Табличные пространства
- В отличие от логического рапсределения объектов по базам данных и схемам, `табличные пространства` определяют физическое расположение данных. Фактически табличное пространство - это каталог файловой системы.
- При инициализации кластера создаются два табличных пространства:
  - `pg_default` располагается в каталоге PGDATA/base и используется как табличное пространство по умолчанию, если явно не выбрать для этой цели другое пространство.
  - `pg_global` располагается в каталоге PGDATA/global и хранит общие для всего кластера объекты системного каталога.

#### Отношения
- В PostgreSQL, `relation` — это обобщённый термин для структурированных наборов строк (кортежей) с фиксированным набором столбцов (атрибутов). Проще говоря, relation — это таблица в самом классическом понимании, но в более широком смысле так же называют и индексы, последовательности, представления и другие объекты, хранящиеся в системном каталоге.

```sql
SELECT relname, relkind
FROM pg_catalog.pg_class c
     JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = 'public';
```

#### Слои и файлы
- Информация, связанная с отношением, организована в несколько [`слоев`](https://postgrespro.ru/docs/postgresql/16/storage-file-layout) (`forks`) разных типов,каждый из них содержит определенный вид данных.
- Изначально файл представлен единственныч `файлом`. Имя файла состоит из числового идентификатора (**oid**), к которому может быть добавлен суффикс, соответствующий типу слоя.
- Файл постепенно растет, и когда его размер достигает 1 Гбайта, создается следующий файл этого же слоя (такие файлы иногда называют `сегментами`). Порядковый номер сегмента добавляется в конец имени файла.

Имеютмя несколько стандартных типов слоев:

- `Основной слой` (**main fork**) – это собственно данные: те самые табличные или индексные строки. Основной слой существует для любых отношений (кроме представлений, которые не содержат данных).
```
CREATE UNLOGGED TABLE t(
  a integer,
  b numeric,
  c text,
  d json
);
```
```
INSERT INTO t VALUES (1, 2.0, 'foo', '{}');
```
```
SELECT pg_relation_filepath('t');
```

output:
```
base/24576/24577
(1 row)
```

Каталог **base** соответствует табличному пространству `pg_default`, следующий подкаталог – базе данных, и уже в нем находится интересующий нас файл:
```
SELECT oid FROM pg_database WHERE datname = 'mydb';
```
output:
```
  oid  
-------
 24576
(1 строка)
```

```
SELECT relfilenode FROM pg_class WHERE relname = 't';
```
output:
```
 relfilenode 
-------------
       24577
(1 строка)
```

Вот соответствующий файл в файловой системе:
```
SELECT size
FROM pg_stat_file('/user/local/pgsql/data/base/24576/24577');
```
output:
```
 size 
------
 8192
(1 строка)
```

- `Слой инициализации` (**init fork**) – существует только для нежурналируемых таблиц (созданных с указанием UNLOGGED) и их индексов. Такие объекты ничем не отличаются, кроме того, что действия и ними не записываются в журнал предзаписи. За счет этого работа с ними происходит быстрее, но в случае сбоя невозможно восстановить данные в согласованном состоянии. Он имеет такое же имя, как и основной слой, но с суффиксом `_init`:
```
SELECT size
FROM pg_stat_file('/user/local/pgsql/data/base/24576/24577_init');
```
output:
```
 size 
------
    0
(1 строка)
```

- `Карта свободного пространства` (**free space map**) – слой, в котором отслеживается примерный объем свободного места внутри страниц. Этот объем постоянно меняется: при добавлении новых версий строк уменьшается, при очистке – увеличивается. Карта свободного пространства используется при вставке новых версий строк, чтобы быстро найти подходящую страницу, на которую поместятся добавляемые данные. Файлы, относящиеся к карте свободного пространства, имеют суффикс `_fsm`. Но появляются не сразу, а только при необходимости. Самый быстрый способ добиться этого – выполнить очистку таблицы:
```
VACUUM t;
```
```
SELECT size
FROM pg_stat_file('/user/local/pgsql/data/base/24576/24577_fsm');
```
output:
```
 size  
-------
 24576
(1 строка)
```

Для ускорения поиска карта свободного пространства организована как дерево и занимает минимум три страницы (отсюда и размер файла слоя для почти пустой таблицы).

- `Карта видимости` (**visibility map**) – слой, который позволяет быстро определить, требует ли страница очистки или заморозки. Для этого на каждую табличную страницу в этом слое отведено два бита.

Файл карты видимости имеют суффикс `_vm`. Обычно они самые небольшие по размеру:
```
SELECT size
FROM pg_stat_file('/user/local/pgsql/data/base/24576/24577_vm');
```
output:
```
 size  
-------
 8192
(1 строка)
```
Карта видимости существует для таблиц, но не для индексов.

### Страницы
Для удобства организации вводы-вывода файлы логически поделены на `страницы` (или `блоки`) – это минимальный объем данных, который считывается или записывается. Обычно страница имеет размер 8 Кбайт.

### TOAST
Каждая строка должна помещаться целиком на одну страницу: нет способа "продолжить" строку на следующей странице. Для длинных строк используется технология, названная `TOAST` (The Oversized Attributes Storage Technique)

TOAST подразумевает несколько стратегий. Длинные значения атрибутов можно отправить в отдельную служебную таблицу, предварительно нарезав на небольшие фрагменты – "тосты". Другой вариант – сжать длинное значение так, чтобы строка все-таки поместилась в одну страницу. А можно и то и другое: сначала сжать, а уже потом нарезать и отправить.

Если основная таблица содержит потенциально длинные атрибуты, для нее сразу же создается отдельная toast-таблица (одна для всех атрибутов). Например, если в таблице есть столбец типа `numeric` или `text`, toast-таблица будет создана, даже если в таком столбце никогда не будет храниться длинные значения.

Для индексов технология TOAST предлагает только сжатие; вынесение атрибутов в отдельную таблицу не поддерживается. Это накладывает ограничение на размер индексируемых ключей.

Обычно стратегии опредебяются типами столбцов. Посмотреть стратегии:
```
\d+
```
или
```
SELECT attname, atttypid::regtype,
CASE attstorage
  WHEN 'p' THEN 'plain'
  WHEN 'e' THEN 'external'
  WHEN 'm' THEN 'main'
  WHEN 'x' THEN 'extended'
END AS storage
FROM pg_attribute
WHERE attrelid = 't'::regclass AND attnum > 0;
```
output:
```
 attname | atttypid | storage  
---------+----------+----------
 a       | integer  | plain
 b       | numeric  | main
 c       | text     | extended
 d       | json     | extended
(4 строки)
```

Стратегии состоят в следующем:

- **plain** – TOAST не используется (стратегия применяется для заведомо "коротких" типов данных, как **integer**).
- **extended** – допускается как сжатие, так и хранение в отдельной toast-таблице.
- **external** – длинные значения хранятся в toast-таблице несжатыми.
- **main** – длинные значения в первую очередь сжимаются, а в toast-таблицу попадают, только если сжатие не помогло.

Иногда может оказаться полезным изменить стратегию для некоторых столбцов. Если заранее известно, что данные в столбце не сжимаются (например, в столбце хранятся JPEG-изображения), можно установить для него стратегию `external` – это позволит сэкономить на бесполезных попытках сжатия. Изменить стратегию можно как при создании таблицы (предложение `STORAGE` команды `CREATE TABLE`), так и впоследствии:
```
ALTER TABLE t ALTER COLUMN d SET STORAGE external;
```
Для сжатия доступны два алгоритма: PGLZ (по умолчанию) и LZ4. Эталонные тесты показывают, что при сходном с PGLZ уровне сжатия LZ4 тратит меньше ресурсов процессора.

Toast-таблицы располагаются в отдельной схеме `pg_toast`, не входящей в путь поиска, и поэтому обычно не видны. Для временных используется схема `pg_toast_temp_N` аналогично обычной `pg_temp_N`.

Скажем, в таблице **t** есть три потенциально длинных атрибута, поэтому toast-таблица обязана быть:

```
SELECT relnamespace::regnamespace, relname
FROM pg_class WHERE oid = (
SELECT reltoastrelid FROM pg_class WHERE relname = 't'
);
```
output:
```
 relnamespace |    relname     
--------------+----------------
 pg_toast     | pg_toast_24577
(1 строка)
```

```
 \d+ pg_toast.pg_toast_24577
```
output:
```
TOAST-таблица "pg_toast.pg_toast_24577"
  Столбец   |   Тип   | Хранилище 
------------+---------+-----------
 chunk_id   | oid     | plain
 chunk_seq  | integer | plain
 chunk_data | bytea   | plain
Принадлежит таблице: "public.t"
Индексы:
    "pg_toast_24577_index" PRIMARY KEY, btree (chunk_id, chunk_seq)
Метод доступа: heap
```

Вместе с toast-таблицей в той же схеме создается индекс, который всегда используется для доступа к фрагментам значений. Имя индекса видно в выводе команды, но его можно найти и запросом:
```
SELECT indexrelid::regclass FROM pg_index
WHERE indrelid = (
  SELECT oid FROM pg_class WHERE relname = 'pg_toast_24577'
);
```
output:
```
          indexrelid           
-------------------------------
 pg_toast.pg_toast_24577_index
(1 строка)
```

```
\d pg_toast.pg_toast_24577_index
```
output:
```
Нежурналируемый индекс "pg_toast.pg_toast_24577_index"
  Столбец  |   Тип   | Ключевой? | Определение 
-----------+---------+-----------+-------------
 chunk_id  | oid     | да        | chunk_id
 chunk_seq | integer | да        | chunk_seq
первичный ключ, btree, для таблицы "pg_toast.pg_toast_24577"
```

Столбец `c` использует стратегию `extended`, значения в нем будут сжиматься:

```
UPDATE t SET c = repeat('A', 5000);
SELECT * FROM pg_toast.pg_toast_24577;
```
output:
```
 chunk_id | chunk_seq | chunk_data 
----------+-----------+------------
(0 строк)
```
В toast-таблице ничего нет: повторяющиеся символы сжались алгоритмом LZ, и послеэтого значение поместилось в обычной табличной странице.

А теперь составим значение из случайных символов:
```
UPDATE t SET c = (
  SELECT string_agg(chr(trunc(65+random()*26)::integer), '')
  FROM generate_series(1, 5000)
)
RETURNING left(c, 10) || '...' || right(c, 10);
```
output:
```
        ?column?         
-------------------------
 XPXCFCGSVF...HWJCTWJBRS
(1 строка)
```

Такую последовательность сажть не получится, и она попадает в toast-таблицу:
```
SELECT chunk_id,
  chunk_seq,
  length(chunk_data),
  left(encode(chunk_data, 'escape')::text, 10) || '...' ||
  right(encode(chunk_data, 'escape')::text, 10)
FROM pg_toast.pg_toast_24577;
```
output:
```
 chunk_id | chunk_seq | length |        ?column?         
----------+-----------+--------+-------------------------
    24617 |         0 |   1996 | XPXCFCGSVF...BAMUOSVEJE
    24617 |         1 |   1996 | OSWVPXOCAK...UALTRWBUPX
    24617 |         2 |   1008 | UDHWICSRUX...HWJCTWJBRS
(3 строки)
```

Видно,что данные нарезаны на фрагменты. Размер фрагментов выбирается так,чтобы на странице toast-таблицы помещалось четыре строки.

Если клиент запрашивает начальную часть длинного значения, то будут прочитаны только необходимые фрагменты, в том числе и в случае, когда значение хранится в сжатом виде.

Тем не менее и на сжатие с нарезкой, и на последующее восстановление тратится довольно много ресурсов. Поэтому хранить объемные данные в PostgreSQL – не лучшая идея, особенно если они активно используются и при этом для них не требуется транзакционная логика (как пример: отсканированные оригиналы бухгалтерских документов). Потенциально более выгодная альтернатива – хранить такие данные в файловой системе, а в базе данных держать только имена соответствующих файлов. Правда, тогда СУБД не сможет обеспечивать согласованность данных.

### Процессы и память
Экземпляр сервера PostgreSQL состоит из нескольких взаимодействующих процессов.

В первую очередь при старте сервера запучкается процесс `postgres`, традиционно называемый `postmaster`. Postmaster запускает все остальные процессы (в Unix-подобных системах для этого используется системный вызов "fork") и "присматривает" за ними – если какой-нибудь процесс завершается аварийно, postmaster перезапустит его (или весь сервер, если сочтет, что процесс мог повредить общие данные).

Работу сервера обеспечивает ряд служебных процессов. Основные из них:
- **startup** восстанавливает систему после сбоев
- **autovacuum** очищает таблицы и индексы от неактуальных данных
- **wal writer** записывает на диск журнальные данные
- **checkpointer** выполняет контрольную точку
- **writer** записывает грязные страницы на диск
- **wal sender** передает журнальные записи на реплику
- **wal receiver** принимает журнальные записи на реплике

Некоторые из этих процессов завершаются после выполнения своей задачи, другие работают постоянно в фоновом режиме, а какие-то могут быть отключены.

Чтобы процессы могли обмениваться информацией, postmaster выделяет `общую память`, которая доступна всем процессам.

Из-за того, что диски (особенно HDD, но и SSD тоже) работают значительно медленнее, чем оперативная память, применяется кеширование: в общей области оперативной памяти отводится место под недавно прочитанные страницы в надежде, что они еще не раз понадобятся и можно будет сэкономить на повторном обращении к диску. Измененные данные также записываются на диск не сразу, а через некоторое время.

Буферный кеш занимает бОльшую часть общей памяти. В ней же располагаются и другие буферы, которые используются сервером для ускорения работы с диском.

При сбое (например, при аварийном отключении питания или крахе операционной системы) содержимое оперативной памяти, включая буферный кеш, пропадает. На диске остаются файлы, страницы которых записаны в разные моменты времени. Чтобы иметь возможность восстановить соглавованность данных, в процессе работы PostgreSQL ведет `журнал предзаписи` (`WAL`), позволяющий при необходимости выполнить потерянные операции повторно.

## Клиенты и клиент-серверный протокол

Еще одна задача процесса postmaster – слушать входящие соединения. При появлении нового клиента postmaster порождает для него **обслуживающий процесс** (**backend**). Клиент устанавливает соединение и начинает *сеанс* общения со своим серверным процессом. Сеанс продолжается до отключения клиента или разрыва связи.

Для каждого клиента на сервере порождается собственной обслуживающий процесс. Большое количество подключений может вызывать проблемы:
- Каждому процессу требуется оперативная память кеша системного каталога, подготовленных запросов, промежуточных результатов при выполнении запросов и других данных.
- Если подключения выполняются часто, а сеансы при это кототкие (т.е. клиент выполняет один небольшой запрос и отключается).
- Чем больше запущено процессов, тем больше времени требуется на просмотр их списка, а эта операция выполняется очень часто. В результате с увеличением числа клиентов производительность может падать.

В таких случаях ипользуют **пул соединений**, чтобы ограничить число обслуживающих процессов.

Чтобы клиент и сервер понимали друг друга, они должны использовать один и тот же протокол взаимодействия. Говоря в самых общих чертах, протокол позволяет клиенту подключиться к серверу и выполнять SQL-запросы.

SQL-запросы передаются обслуживающему процессу в текстовом виде. Процесс разбирает текст, оптимизирует запрос, выполняет его и возвращает результат клиенту.

---

## Глава 2. Изоляция

### Согласованность
Важная особенность реляционных СУБД – обеспечение **согласованности** (consistency), то есть **корректности данных**.

Известно, что на уровне базы данных можно создавать **ограничения целостности** (integrity constraints), такие как NOT NULL или UNIQUE. СУБД следит за тем, чтобы данные никогда не нарушали эти ограничения, т.е. оставались целостными.

`Транзакция` - неделимость операции, что несколько (например, две) операции составляют неделимое целое и решает задачу согласованности, 

Транзакции, абсолютно правильные сами по себе, при одновременном выполнении могут начать работать некорректно. Это происходит из-за того, что перемешивается порядок выполнения операция разных транзакций.

Ситуации, когда корректные транзакции некорректно работают вместе, называют `аномалиями` одновременного выполнения.

#### Пример
Если приложение хочет получить из базы согласованные данные, то оно как минимум не должно видеть изменения других незафиксированных транзакций. Иначе (если какая-либо транзакция будет отменена) можно увидеть состояние, в котором база данных никогда не находилась. Такая аномалия называется `грязным чтением`. Есть множество других, более сложных аномалий.

Роль СУБД состоит в том, чтобы выполнять транзакции параллельно и при этом гарантировать, что результат такого одновременного выполнения будет совпадать с результатом одного из возможных последовательных выполнений. Иными словами – `изолировать` транзакции друг от друга, устранив любые возможные аномалии.

Таким образом, транзакцией называется множество операций, которые переводят базу данных из одного корректного состояния в другое корректное состояние (**согласованность**) при условии, что транзакция выполнена полностью (**атомарность**) и без помех со стороны других транзакций (**изоляция**). Это определение объединяет требования, стоящие за первыми тремя буквами акронима `ACID`: **Atomicity**, **Consistency**, **Isolation**. Они настолько тесно связаны друг с другом, что рассматривать их по отдельности просто нет смысла. На самом деле сложно и требование долговечности (Durability), ведь при крахе системы в ней остаются изменения незафиксированных транзакций, а с ними приходится что-то делать, чтобы восстановить согласованность данных.

### Уровни изоляции и аномалии в стандарте SQL
Стандарт SQL описывает четыре уровня [изоляции](https://postgrespro.ru/docs/postgresql/16/transaction-iso). Эти уровни определяются перечислением аномалий, которые допускаются или не допускаются при одновременном выполнении транзакций. Поэтому разговор об уровнях прижется начать с аномалий.

#### Потерянное обновление (Lost Update)
Аномалия **потерянного обновления** возникает, когда две транзакции читают одну и ту же строку таблицы, затем одна из них обновляет эту строку, после чего вторая обновляет эту же строку, не учитывая изменений, сделанных первой транзакцией.

Например, две транзакции собираются увеличить сумму на одном и том же счете на 100 ₽. Первая транзакция читает текущее значение (1000 ₽), затем вторая транзакция читает тоже самое значение. Первая увеличивает сумму (получается 1100₽) и записывает в базу это новое значение. Вторая поступает так же: получает те же 1100 ₽ и записывает их. В результате клиент потерял 100 ₽.

Потерянное обновление не допускается стандартом ни на одном уровне изоляции.

#### Грязное чтение (dirty read) и Read Uncommitted
Аномалия **грязного чтения** возникает, когда транзакция читает еще не зафиксированные изменения, сделанные другой транзакцией.

Например, первая транзакция переводит 100 ₽ на пустой счет клиента, но не фиксирует изменение. Другая транзакция читает состояние счета (обновленное, но не зафиксированное) и позволяет клиенту снять наличные — несмотря на то, что первая транзакция прерывается и отменяет свои изменения, так что никаких денег на счете клиента нет.

Грязное чтение допускается стандартом на уровне **Read Uncommitted**.

#### Неповторяющееся чтение (non-repeatable read) и Read Committed
Аномалия **неповторяющегося чтения** возникает, когда транзакция читает одну и ту же строку два раза, а в промежутке между чтениями вторая транзакция изменяет (или удаляет) эту строку и фиксирует изменения. Тогда первая транзакция получит разные результаты.

Например, пусть правило согласованности запрещает отрицательные суммы на счетах клиентов. Первая транзакция собирается уменьшить сумму на счете на 100 ₽. Она проверяет текущее значение, получает 1000 ₽ и решает, что уменьшение возможно. В это время вторая транзакция уменьшает сумму на счете до нуля и фиксирует изменения. Если бы теперь первая транзакция повторно проверила сумму, она получила бы 0 ₽ (но она уже приняла решение уменьшить значение, и счет «уходит в минус»).

Неповторяющееся чтение допускается стандартом на уровнях **Read Uncommitted** и **Read Committed**.

#### Фантомное чтение (phantom read) и Repeatable Read
Аномалия **фантомного чтения** возникает, когда одна транзакция два раза читает набор строк по одинаковому условию, а в промежутке между чтениями другая транзакция добавляет строки, удовлетворяющие этому условию, и фиксирует изменения. Тогда первая транзакция получит разные наборы строк.

Например, пусть правило согласованности запрещает клиенту иметь более трех счетов. Первая транзакция собирается открыть новый счет, проверяет их текущее количество (скажем, два) и решает, что открытие возможно. В это время вторая транзакция тоже открывает клиенту новый счети фиксирует изменения. Если бы теперь первая транзакция перепроверила количество, она получила бы три (но она уже выполняет открытие еще одного счета, и у клиента их оказывается четыре).

Фантомное чтение допускается стандартом на уровнях **Read Uncommitted**, **Read Committe**d и **Repeatable Read**.

#### Отсутствие аномалий и Serializable
Стандарт определяет и уровень, на котором не допускаются никакие аномалии, – Serializable. И это совсем не то же самое, что запрет на потерянное обновление и на грязное, неповторяющееся и фантомное чтение. Дело в том, что существует значительно больше известных аномалий, чем перечисленно в стандарте, и еще неизвестное число пока неизвестных.

Уровень Serializable должен предотвращать любые аномалии. Это означает, что на таком уровне разработчику приложения не надо думать об изоляции. Если транзакции выполняют корректные последовательности операторов, работая в одиночку,данные останутся согласованными и при одновременной работе этих транзакций.

В качестве иллюстрации приведу известную всем таблицу из стандарта, к которой для ясности добавлен последний столбец:

|                   | потерянные обновления | грязное чтение | неповторяющееся чтение | фантомное чтение | другие аномалии |
| ----------------- | --------------------- | -------------- | ---------------------- | ---------------- | --------------- |
| Read Uncommitted  | -                     | да             | да                     | да               | да              |
| Read Committed    | -                     | -              | да                     | да               | да              |
| Repeatable Read   | -                     | -              | -                      | да               | да              |
| Serializable      | -                     | -              | -                      | -                | -               |

### Уровни изоляции в PostgreSQL
Со временем на смену блокировочным протоколам управления транзакциями пришел `протокол изоляции на основе снимков` (`Snapshot Isolation, SI`). Его идея состоит в том, что каждая транзакция работает с согласованным снимком данных на определенный момент времени. В снимок попадают все актуальные изменения, зафиксированные до момента его создания.

Изоляция на основе снимков позволяет обходиться минимумом блокировок. Фактически блокируется только повторное изменение одной и той же строки. Все остальные операции могут выполняться одновременно: пишущие транзакции никогда не блокируют читающие транзакции, а считывающие вообще никогда никого не блокируют.

В PostgreSQL реализован **многоверсионный** вариант протокола SI. Многоверсионность подразумевает, что в СУБД в один момент времени могут сосуществовать несколько версий одной и той же строки. Это позволяет включать в снимок подходящую версию, а не обрывать транзакции, пытающиеся прочитать устаревшие данные.

За счет использования снимков данных изоляция в PostgreSQL отличается от той, что требует стандарт, и в целом она строже:

|                   | потерянные обновления | грязное чтение | неповторяющееся чтение | фантомное чтение | другие аномалии |
| ----------------- | --------------------- | -------------- | ---------------------- | ---------------- | --------------- |
| Read Committed    | да                    | -              | да                     | да               | да              |
| Repeatable Read   | -                     | -              | -                      | -                | да              |
| Serializable      | -                     | -              | -                      | -                | -               |


Перед тем как исследовать внутреннее устройство изоляции, давайте подробно рассмотрим каждый из трех уровней с точки зрения пользователя.

Для этого создадим таблицу счетов. У Алисы и Боба по 1000 ₽, но у Боба открыто два счета:

```
CREATE TABLE accounts(
  id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  client text,
  amount numeric
);
```
```
INSERT INTO accounts VALUES
  (1, 'alice', 1000.00),
  (2, 'bob', 100.00),
  (3, 'bob', 900.00);
```

#### Read Committed
- **Отсутствие грязного чтения**. Легко убедиться в том, что грязные данные прочитать невозможно. Начнем транзакцию. По умолчанию она использует уровень изоляции Read Committed:
```
BEGIN;
SHOW transaction_isolation;
```
output:
```
 transaction_isolation 
-----------------------
 read committed
(1 строка)
```

Говоря точнее, умолчательный уровень задается параметром, который при необходимости можно изменить:
```
SHOW default_transaction_isolation;
```
output:
```
 default_transaction_isolation 
-------------------------------
 read committed
(1 строка)
```

Итак, в открытой транзакции снимаем средства со счета, но не фиксируем изменения. Свои собственные изменения транзакция всегда видит:
```
UPDATE accounts SET amount = amount - 200 WHERE id = 1;
SELECT * FROM accounts WHERE client = 'alice';
```
output:
```
 id | client | amount 
----+--------+--------
  1 | alice  | 800.00
(1 строка)
```

Во втором сеансе начинаем еще одну транзакцию с тем же уровнем Read Committed:
```
BEGIN;
SELECT * FROM accounts WHERE client = 'alice';
```
output:
```
 id | client | amount  
----+--------+---------
  1 | alice  | 1000.00
(1 строка)
```

Как ожидалось, другая транзакция не видит незафиксированные изменения – грязное чтение не допучкается.

- **Неповторяющееся чтения**. Пусть теперь первая транзакция зафиксирует изменения, а вторая повторно тот же самый запрос:
Первая:
```
COMMIT;
```

Вторая:
```
SELECT * FROM accounts WHERE client = 'alice';
```
output:
```
 id | client | amount 
----+--------+--------
  1 | alice  | 800.00
(1 строка)
```
```
COMMIT;
```

Запрос получает уже новые данные – это и есть аномалия **неповторяющегося чтения**, которая допускается на уровне Read Committed.

**Практический вывод**: в транзакции нельзя принимать решения на основании данных, прочитанных предыдущим оператором, ведь за время между выполнением операторов все может измениться. Вот пример, вариации которого встречаются в прикладном коде так часто, что он является классическим антипаттерном:

```
DO $$
BEGIN
  IF (SELECT amount FROM accounts WHERE id = 1) >= 1000 THEN
    UPDATE accounts
    SET    amount = amount - 1000
    WHERE  id = 1;
  END IF;
END;
$$ LANGUAGE plpgsql;
DO
```

За время, которое проходит между проверкой и обновлением, другие транзакции могут как угодно изменить состояние счет, так что такая "проверка" ни от чего не спасает. Удобно представлять себе, что между операторами одной транзакции могут "вклиниться" произвольные операторы других транзакций, например вот так:

Первая:
```
IF (SELECT amount FROM accounts WHERE id = 1) >= 1000 THEN
```

Вторая:
```
UPDATE accounts SET amount = amount - 200 WHERE id = 1;
COMMIT;
```

Первая:
```
  UPDATE accounts SET amount = amount - 1000 WHERE id = 1;
END IF;
```

Как написать код корректно? Есть несколько возможностей:
- Заменить процедурный код декларатвным.
Например, в данном случае проверка легко превращается в ограничение целостности:
```
ALTER TABLE accounts ADD CHECK amount >= 0;
```
Теперь никакие проверки в коде не нужны: достаточно просто выполнить действие и при необходимости обработать исключение, которое возникает в случае попытки нарушения целостности.

- Использовать один оператор SQL
Проблема с согласованностью возникают из-за того, что в промежутке между операторами может завершиться другая транзакция.

- Задействовать пользовательские блокировки
Вручную установить исключительную блокировку на все нужные строки (**SELECT FOR UPDATE**) или вообще на всю таблицу (**LOCK TABLE**). Это всегда работает, но сводит на нет преимущества многоверсионности: вместо одновременного выполнения часть операций будет выполняться последовательно.


- **Несогласованное чтения**. Однако не все так просто. Реализация PostgreSQL такова, что допускает другие, менее известные аномалии, которые не регламентируются стандартом.

Допустим, первая транзакция начала перевод средств с одного счета Боба на другой:
```
BEGIN;
UPDATE accounts SET amount = amount - 100 WHERE id = 2;
```

В это время другая транзакция подсчитывает баланс Боба, причем подсчет выполнения в цикле по всем счетам Боба. Фактически транзакция начинает с первого счета (и, разумеется, видит прежнее состояние):
```
BEGIN;
SELECT amount FROM accounts WHERE id = 2;
```
output:
```
 amount 
--------
 100.00
(1 строка)
```

В этот момент первая транзакция успешно завершается:
```
UPDATE accounts SET amount = amount + 100 WHERE id = 3;
COMMIT;
```

А другая читает состояние сторого счета (и видит уже новое значение):
```
SELECT amount FROM accounts WHERE id = 3;
```
output:
```
 amount  
---------
 1000.00
(1 строка)
```
```
COMMIT;
```

В итоге вторая транзакция получила в сумме 1100 ₽, т.е. прочитала некорректные данные. Такая аномалия называется **несогласованным чтением** (**read skew**).

Как избежать этой аномалии, оставаясь на уровне Read Committed? Конечно, использовать один оператор. Например, так:
```
SELECT sum(amount) FROM accounts WHERE client = 'bob';
```




































