# PostgreSQL 16 изнутри
by Рогов Егор Валерьевич

- Часть 0.
  - Глава 1. Введение
    1. Организация данных
    2. Процессы и память
    3. Клиенты и клиент - серверный протокол
- Часть I. Изоляция и многоверсионность
  - Глава 2. Изоляция
    1. Согласованность
    2. Уровни изоляции и аномалии в стандарте SQL
    3. Уровни изоляции в PostgreSQL
   
---

## Глава 1. Введение

### Организация данных

#### Базы данных
- `PostgreSQL` - программа, которая относится к классу систем управления [базами данных](https://postgrespro.ru/docs/postgresql/16/managing-databases). Когда эта программа выполняется, мы называем ее `сервером` PostgreSQL, или `экземпляром` сервера.
- Данные, которыми управляет PostgreSQL, хранятся в `базах данных`.
- Один экземпляр PostgreSQL одновременно работает с несколькими базами, которые вместе называются `кластером баз данных`.
- Чтобы кластер можно было использовть, его необходимо `инициализировать` [[`initdb`](https://postgrespro.ru/docs/postgresql/16/app-initdb)]. Каталог, в котором размещаются все файлы, относящиеся к кластеру, обычно называют словом `PGDATA`. Обычно `PGDATA` находится в `/var/lib/pgsql/data`.
- При инициализации в PGDATA создаются три одинаковые базы данных:
  - `template0` - неизменяемый эталон
  - `template1` - настраиваемый шаблон для новых баз.
  - `postgres` - удобная «рабочая» БД для администрирования и тестов.
 
#### Системный каталог
- Метаинформация обо всех объектах кластера (таких как таблицы, индексы, типы данных или функции) хранится в таблицах, относящихся к [`системному каталогу`](https://postgrespro.ru/docs/postgresql/16/catalogs).
- К системному каталогу можно обращаться с помощью обычных запросов SQL, а изменения в нем происходят при выполнении команд DDL.

#### Схемы
- [`Схемы`](https://postgrespro.ru/docs/postgresql/16/ddl-schemas) представляют собой пространства имен для всех объектов, хранящихся в базе данных.
- Кроме пользовательских схем, имеется несколько специальных служебных:
  - `public` используется по умолчанию для пользовательских объектов, если не выполнены иные настройки
  - `pg_catalog` используется для таблиц системного каталога
  - `information_schema` дает альтернативное представление системного каталога, регламентируемое стандартом SQL
  - `pg_toast` используется для объектов, относящихся к TOAST
  - `pg_temp` объединяет временные таблицы

 #### Табличные пространства
- В отличие от логического рапсределения объектов по базам данных и схемам, `табличные пространства` определяют физическое расположение данных. Фактически табличное пространство - это каталог файловой системы.
- При инициализации кластера создаются два табличных пространства:
  - `pg_default` располагается в каталоге PGDATA/base и используется как табличное пространство по умолчанию, если явно не выбрать для этой цели другое пространство.
  - `pg_global` располагается в каталоге PGDATA/global и хранит общие для всего кластера объекты системного каталога.

#### Отношения
- В PostgreSQL, `relation` — это обобщённый термин для структурированных наборов строк (кортежей) с фиксированным набором столбцов (атрибутов). Проще говоря, relation — это таблица в самом классическом понимании, но в более широком смысле так же называют и индексы, последовательности, представления и другие объекты, хранящиеся в системном каталоге.

```sql
SELECT relname, relkind
FROM pg_catalog.pg_class c
     JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = 'public';
```

#### Слои и файлы
- Информация, связанная с отношением, организована в несколько [`слоев`](https://postgrespro.ru/docs/postgresql/16/storage-file-layout) (`forks`) разных типов,каждый из них содержит определенный вид данных.
- Изначально файл представлен единственныч `файлом`. Имя файла состоит из числового идентификатора (**oid**), к которому может быть добавлен суффикс, соответствующий типу слоя.
- Файл постепенно растет, и когда его размер достигает 1 Гбайта, создается следующий файл этого же слоя (такие файлы иногда называют `сегментами`). Порядковый номер сегмента добавляется в конец имени файла.

Имеютмя несколько стандартных типов слоев:

- `Основной слой` (**main fork**) – это собственно данные: те самые табличные или индексные строки. Основной слой существует для любых отношений (кроме представлений, которые не содержат данных).
```
CREATE UNLOGGED TABLE t(
  a integer,
  b numeric,
  c text,
  d json
);
```
```
INSERT INTO t VALUES (1, 2.0, 'foo', '{}');
```
```
SELECT pg_relation_filepath('t');
```

output:
```
base/16384/16385
(1 row)
```

Каталог **base** соответствует табличному пространству `pg_default`, следующий подкаталог – базе данных, и уже в нем находится интересующий нас файл:
```
SELECT oid FROM pg_database WHERE datname = 'mydb';
```
output:
```
  oid  
-------
 16384
(1 строка)
```

```
SELECT relfilenode FROM pg_class WHERE relname = 't';
```
output:
```
 relfilenode 
-------------
       16385
(1 строка)
```

Вот соответствующий файл в файловой системе:
```
SELECT size
FROM pg_stat_file('/user/local/pgsql/data/base/16384/16385');
```
output:
```
 size 
------
 8192
(1 строка)
```

- `Слой инициализации` (**init fork**) – существует только для нежурналируемых таблиц (созданных с указанием UNLOGGED) и их индексов. Такие объекты ничем не отличаются, кроме того, что действия и ними не записываются в журнал предзаписи. За счет этого работа с ними происходит быстрее, но в случае сбоя невозможно восстановить данные в согласованном состоянии. Он имеет такое же имя, как и основной слой, но с суффиксом `_init`:
```
SELECT size
FROM pg_stat_file('/user/local/pgsql/data/base/16384/16385_init');
```
output:
```
 size 
------
    0
(1 строка)
```

- `Карта свободного пространства` (**free space map**) – слой, в котором отслеживается примерный объем свободного места внутри страниц. Этот объем постоянно меняется: при добавлении новых версий строк уменьшается, при очистке – увеличивается. Карта свободного пространства используется при вставке новых версий строк, чтобы быстро найти подходящую страницу, на которую поместятся добавляемые данные. Файлы, относящиеся к карте свободного пространства, имеют суффикс `_fsm`. Но появляются не сразу, а только при необходимости. Самый быстрый способ добиться этого – выполнить очистку таблицы:
```
VACUUM t;
```
```
SELECT size
FROM pg_stat_file('/user/local/pgsql/data/base/16384/16385_fsm');
```
output:
```
 size  
-------
 24576
(1 строка)
```

Для ускорения поиска карта свободного пространства организована как дерево и занимает минимум три страницы (отсюда и размер файла слоя для почти пустой таблицы).

- `Карта видимости` (**visibility map**) – слой, который позволяет быстро определить, требует ли страница очистки или заморозки. Для этого на каждую табличную страницу в этом слое отведено два бита.

Файл карты видимости имеют суффикс `_vm`. Обычно они самые небольшие по размеру:
```
SELECT size
FROM pg_stat_file('/user/local/pgsql/data/base/16384/16385_vm');
```
output:
```
 size  
-------
 8192
(1 строка)
```
Карта видимости существует для таблиц, но не для индексов.

### Страницы
Для удобства организации вводы-вывода файлы логически поделены на `страницы` (или `блоки`) – это минимальный объем данных, который считывается или записывается. Обычно страница имеет размер 8 Кбайт.

### TOAST
Каждая строка должна помещаться целиком на одну страницу: нет способа "продолжить" строку на следующей странице. Для длинных строк используется технология, названная `TOAST` (The Oversized Attributes Storage Technique)

TOAST подразумевает несколько стратегий. Длинные значения атрибутов можно отправить в отдельную служебную таблицу, предварительно нарезав на небольшие фрагменты – "тосты". Другой вариант – сжать длинное значение так, чтобы строка все-таки поместилась в одну страницу. А можно и то и другое: сначала сжать, а уже потом нарезать и отправить.

Если основная таблица содержит потенциально длинные атрибуты, для нее сразу же создается отдельная toast-таблица (одна для всех атрибутов). Например, если в таблице есть столбец типа `numeric` или `text`, toast-таблица будет создана, даже если в таком столбце никогда не будет храниться длинные значения.

Для индексов технология TOAST предлагает только сжатие; вынесение атрибутов в отдельную таблицу не поддерживается. Это накладывает ограничение на размер индексируемых ключей.

Обычно стратегии опредебяются типами столбцов. Посмотреть стратегии:
```
\d+
```
или
```
SELECT attname, atttypid::regtype,
CASE attstorage
  WHEN 'p' THEN 'plain'
  WHEN 'e' THEN 'external'
  WHEN 'm' THEN 'main'
  WHEN 'x' THEN 'extended'
END AS storage
FROM pg_catalog.pg_attribute
WHERE attrelid = 't'::regclass AND attnum > 0;
```
output:
```
 attname | atttypid | storage  
---------+----------+----------
 a       | integer  | plain
 b       | numeric  | main
 c       | text     | extended
 d       | json     | extended
(4 строки)
```






























